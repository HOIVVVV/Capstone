{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { Component, Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Input, NgModule, NgZone, Optional, Output, ViewChild, ViewContainerRef, ViewEncapsulation } from '@angular/core';\nimport { Observable as Observable$1 } from 'rxjs/Observable';\nimport { ReplaySubject as ReplaySubject$1 } from 'rxjs/ReplaySubject';\nimport { first as first$1 } from 'rxjs/operator/first';\nimport { Subject as Subject$1 } from 'rxjs/Subject';\nimport { debounceTime as debounceTime$1 } from 'rxjs/operator/debounceTime';\nimport { CommonModule } from '@angular/common';\n/**\n * return json string from json-like string\n * @param {?} str\n * @return {?}\n */\n\nfunction jsonize(str) {\n  try {\n    return str;\n  } catch (e) {\n    return str.replace(/([\\$\\w]+)\\s*:/g, // wrap keys without double quote\n    function (_, $1) {\n      return '\"' + $1 + '\":';\n    }).replace(/'([^']+)'/g, // replacing single quote to double quote\n    function (_, $1) {\n      return '\"' + $1 + '\"';\n    });\n  }\n}\n/**\n * Returns string to an object by using JSON.parse()\n * @param {?} input\n * @return {?}\n */\n\n\nfunction getJSON(input) {\n  if (typeof input === 'string') {\n    var\n    /** @type {?} */\n    re = /^[\\+\\-]?[0-9\\.]+,[ ]*\\ ?[\\+\\-]?[0-9\\.]+$/; // lat,lng\n\n    if (input.match(re)) {\n      input = '[' + input + ']';\n    }\n\n    return JSON.parse(jsonize(input));\n  } else {\n    return input;\n  }\n}\n/**\n * Returns camel-cased from string 'Foo Bar' to 'fooBar'\n * @param {?} str\n * @return {?}\n */\n\n\nfunction toCamelCase(str) {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w)/g, function (letter, index) {\n    return index === 0 ? letter.toLowerCase() : letter.toUpperCase();\n  }).replace(/\\s+/g, '');\n}\n/**\n * @return {?}\n */\n\n\nfunction isMapsApiLoaded() {\n  return typeof google === 'object' && typeof google.maps === 'object';\n}\n/**\n * @param {?} component\n * @param {?} libName\n * @return {?}\n */\n\n\nfunction missingLibraryError(component, libName) {\n  return Error(component + \": library '\" + libName + \"' is missing, please ensure to include it in a 'libraries' parameter.\\n    Example:\\n      NguiMapModule.forRoot({\\n        apiUrl: 'https://maps.googleapis.com/maps/api/js?libraries=\" + libName + \"'\\n      })\\n  \");\n}\n/**\n * @abstract\n */\n\n\nvar BaseMapDirective =\n/** @class */\nfunction () {\n  /**\n   * @param {?} nguiMapComponent\n   * @param {?} mapObjectName\n   * @param {?} inputs\n   * @param {?} outputs\n   */\n  function BaseMapDirective(nguiMapComponent, mapObjectName, inputs, outputs) {\n    var _this = this;\n\n    this.nguiMapComponent = nguiMapComponent;\n    this.mapObjectName = mapObjectName;\n    this.inputs = inputs;\n    this.outputs = outputs; // this should be redefined on each childr directive\n\n    this.initialized$ = new EventEmitter();\n    this._subscriptions = [];\n    this.nguiMap = this.nguiMapComponent['nguiMap'];\n    this.optionBuilder = this.nguiMapComponent['optionBuilder']; // all outputs must be initialized\n\n    this.outputs.forEach(function (output) {\n      return _this[output] = new EventEmitter();\n    });\n    this.mapObjectName = mapObjectName;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  BaseMapDirective.prototype.ngOnInit = function () {\n    var _this = this;\n\n    if (this.nguiMapComponent.mapIdledOnce) {\n      this.initialize();\n    } else {\n      this.nguiMapComponent.mapReady$.subscribe(function (map) {\n        return _this.initialize();\n      });\n    }\n  };\n  /**\n   * @return {?}\n   */\n\n\n  BaseMapDirective.prototype.initialize = function () {\n    this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this); // will be set after geocoded\n\n    typeof this.objectOptions.position === 'string' && delete this.objectOptions.position;\n    typeof this.objectOptions.center === 'string' && delete this.objectOptions.center; // noinspection TypeScriptUnresolvedFunction\n\n    if (this.libraryName) {\n      if (!google.maps[this.libraryName]) {\n        throw missingLibraryError(this.mapObjectName, this.libraryName);\n      }\n\n      this.mapObject = new google.maps[this.libraryName][this.mapObjectName](this.objectOptions);\n    } else {\n      this.mapObject = new google.maps[this.mapObjectName](this.objectOptions);\n    }\n\n    this.mapObject.setMap(this.nguiMapComponent.map);\n    this.mapObject['mapObjectName'] = this.mapObjectName;\n    this.mapObject['nguiMapComponent'] = this.nguiMapComponent; // set google events listeners and emits to this outputs listeners\n\n    this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n    this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n    this.initialized$.emit(this.mapObject);\n  };\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n\n\n  BaseMapDirective.prototype.ngOnChanges = function (changes) {\n    this.nguiMap.updateGoogleObject(this.mapObject, changes);\n  };\n  /**\n   * @return {?}\n   */\n\n\n  BaseMapDirective.prototype.ngOnDestroy = function () {\n    this._subscriptions.map(function (subscription) {\n      return subscription.unsubscribe();\n    });\n\n    this.nguiMapComponent.removeFromMapObjectGroup(this.mapObjectName, this.mapObject);\n\n    if (this.mapObject) {\n      this.nguiMap.clearObjectEvents(this.outputs, this, 'mapObject');\n    }\n  };\n\n  return BaseMapDirective;\n}();\n\nBaseMapDirective.propDecorators = {\n  'initialized$': [{\n    type: Output\n  }]\n};\n/**\n * change any object to google object options\n * e.g. [1,2] -> new google.maps.LatLng(1,2);\n */\n\nvar OptionBuilder =\n/** @class */\nfunction () {\n  function OptionBuilder() {}\n  /**\n   * @param {?} definedInputs\n   * @param {?} userInputs\n   * @return {?}\n   */\n\n\n  OptionBuilder.prototype.googlizeAllInputs = function (definedInputs, userInputs) {\n    var _this = this;\n\n    var\n    /** @type {?} */\n    options = {}; // if options given from user, only take options and ignore other inputs\n\n    if (userInputs.options) {\n      console.log('userInputs.options .................', userInputs.options);\n      options = userInputs.options;\n\n      if (!this.onlyOptionsGiven(definedInputs, userInputs)) {\n        console.error('when \"options\" are used, other options are ignored');\n      }\n    } else {\n      definedInputs.forEach(function (input) {\n        if (userInputs[input] !== undefined) {\n          options[input] = _this.googlize(userInputs[input], {\n            key: input\n          });\n        }\n      });\n    }\n\n    return options;\n  };\n  /**\n   * @param {?} inputs\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  OptionBuilder.prototype.googlizeMultiple = function (inputs, options) {\n    options = options || {};\n\n    for (var\n    /** @type {?} */\n    key in inputs) {\n      var\n      /** @type {?} */\n      val = inputs[key]; // (non-strings are fully converted)\n\n      if (typeof val !== 'string') {\n        options[key] = val;\n      } // sometimes '0' needed to stay as it is\n      else if (!(options['doNotConverStringToNumber'] && val.match(/^[0-9]+$/))) {\n        options[key] = this.googlize(val, {\n          key: key\n        });\n      }\n    } // for(var key in attrs)\n\n\n    return options;\n  };\n  /**\n   * @param {?} input\n   * @param {?=} options\n   * @return {?}\n   */\n\n\n  OptionBuilder.prototype.googlize = function (input, options) {\n    options = options || {};\n    var\n    /** @type {?} */\n    output = input;\n\n    if (typeof input === 'string') {\n      if (input === 'false') {\n        output = false;\n      } else if (input === '0') {\n        output = 0;\n      } else {\n        output = // -> googlize -> getJsonParsed -> googlizeMultiple -> googlize until all elements are parsed\n        this.getJSONParsed(input, options)\n        /* Foo.Bar(...) -> new google.maps.Foo.Bar(...) */\n        || this.getAnyMapObject(input)\n        /*  MapTypeID.HYBRID -> new google.maps.MapTypeID.HYBRID */\n        || this.getAnyMapConstant(input, options)\n        /*  2016-06-20 -> new Date('2016-06-20') */\n        || this.getDateObject(input) || input;\n      }\n    }\n\n    if (options['key']) {\n      var\n      /** @type {?} */\n      key = options['key'];\n\n      if (output instanceof Array) {\n        if (key === 'bounds') {\n          output = new google.maps.LatLngBounds(output[0], output[1]);\n        } else if (key === 'icons') {\n          output = this.getMapIcons(output);\n        } else if (key === 'position' || key.match(/^geoFallback/)) {\n          output = this.getLatLng(output);\n        }\n      } else if (output instanceof Object) {\n        if (key === 'icon') {\n          output = this.getMarkerIcon(output);\n        } else if (key.match(/ControlOptions$/)) {\n          output = this.getMapControlOption(output);\n        }\n      }\n    } // delete keys only for processing, not used by google\n\n\n    delete output['doNotConverStringToNumber'];\n    delete output['key'];\n    return output;\n  };\n  /**\n   * @param {?} input\n   * @return {?}\n   */\n\n\n  OptionBuilder.prototype.getLatLng = function (input) {\n    var\n    /** @type {?} */\n    output;\n\n    if (input[0].constructor === Array) {\n      output = input.map(function (el) {\n        return new google.maps.LatLng(el[0], el[1]);\n      });\n    } else if (!isNaN(parseFloat(input[0])) && isFinite(input[0])) {\n      output = new google.maps.LatLng(input[0], input[1]);\n    }\n\n    return output;\n  };\n  /**\n   * @param {?} input\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  OptionBuilder.prototype.getJSONParsed = function (input, options) {\n    var\n    /** @type {?} */\n    output;\n\n    try {\n      output = getJSON(input);\n\n      if (output instanceof Array) {\n        // [{a:1}] : not lat/lng ones\n        if (output[0].constructor !== Object) {\n          output = this.getLatLng(output);\n        }\n      } else if (output === Object(output)) {\n        // check for nested hashes and convert to Google API options\n        var\n        /** @type {?} */\n        newOptions = options;\n        newOptions['doNotConverStringToNumber'] = true;\n        output = this.googlizeMultiple(output, newOptions);\n      }\n    } catch (e) {}\n\n    return output;\n  };\n  /**\n   * @param {?} input\n   * @return {?}\n   */\n\n\n  OptionBuilder.prototype.getAnyMapObject = function (input) {\n    var\n    /** @type {?} */\n    output;\n\n    if (input.match(/^[A-Z][a-zA-Z0-9]+\\(.*\\)$/)) {\n      try {\n        output = Function(\"return new google.maps.\" + input + \";\")();\n      } catch (e) {}\n    }\n\n    return output;\n  };\n  /**\n   * @param {?} input\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  OptionBuilder.prototype.getAnyMapConstant = function (input, options) {\n    var\n    /** @type {?} */\n    output;\n\n    if (input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/)) {\n      try {\n        var\n        /** @type {?} */\n        matches = input.match(/^([A-Z][a-zA-Z0-9]+)\\.([A-Z]+)$/);\n        output = google.maps[matches[1]][matches[2]];\n      } catch (e) {}\n    } else if (input.match(/^[A-Z]+$/)) {\n      try {\n        var\n        /** @type {?} */\n        capitalizedKey = options['key'].charAt(0).toUpperCase() + options['key'].slice(1);\n        output = google.maps[capitalizedKey][input];\n      } catch (e) {}\n    }\n\n    return output;\n  };\n  /**\n   * streetviewControl, panControl, etc, not a general control\n   * @param {?} controlOptions\n   * @return {?}\n   */\n\n\n  OptionBuilder.prototype.getMapControlOption = function (controlOptions) {\n    var\n    /** @type {?} */\n    newControlOptions = controlOptions;\n\n    for (var\n    /** @type {?} */\n    key in newControlOptions) {\n      if (newControlOptions[key]) {\n        var\n        /** @type {?} */\n        value = newControlOptions[key];\n\n        if (typeof value === 'string') {\n          value = value.toUpperCase();\n        } else if (key === 'mapTypeIds') {\n          value = value.map(function (str) {\n            if (str.match(/^[A-Z]+$/)) {\n              return google.maps.MapTypeId[str.toUpperCase()];\n            } else {\n              return str;\n            }\n          });\n        }\n\n        if (key === 'style') {\n          var\n          /** @type {?} */\n          objName = key.replace(/Options$/, '') + 'Style';\n          newControlOptions[key] = google.maps[objName][value];\n        } else if (key === 'position') {\n          newControlOptions[key] = google.maps.ControlPosition[value];\n        } else {\n          newControlOptions[key] = value;\n        }\n      }\n    }\n\n    return newControlOptions;\n  };\n  /**\n   * @param {?} input\n   * @return {?}\n   */\n\n\n  OptionBuilder.prototype.getDateObject = function (input) {\n    var\n    /** @type {?} */\n    output;\n\n    if (input.match(/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT][\\d:\\.]*)?)([zZ]|([+\\-])(\\d\\d):?(\\d\\d))?$/)) {\n      try {\n        output = new Date(input);\n      } catch (e) {}\n    }\n\n    return output;\n  };\n  /**\n   * @param {?} input\n   * @return {?}\n   */\n\n\n  OptionBuilder.prototype.getMapIcons = function (input) {\n    return input.map(function (el) {\n      if (el.icon.path.match(/^[A-Z_]+$/)) {\n        el.icon.path = google.maps.SymbolPath[el.icon.path];\n      }\n\n      return el;\n    });\n  };\n  /**\n   * @param {?} input\n   * @return {?}\n   */\n\n\n  OptionBuilder.prototype.getMarkerIcon = function (input) {\n    var\n    /** @type {?} */\n    output = input;\n\n    if (('' + output.path).match(/^[A-Z_]+$/)) {\n      output.path = google.maps.SymbolPath[output.path];\n    }\n\n    for (var\n    /** @type {?} */\n    key in output) {\n      var\n      /** @type {?} */\n      arr = output[key];\n\n      if (key === 'anchor' || key === 'origin' || key === 'labelOrigin') {\n        output[key] = new google.maps.Point(arr[0], arr[1]);\n      } else if (key === 'size' || key === 'scaledSize') {\n        output[key] = new google.maps.Size(arr[0], arr[1]);\n      }\n    }\n\n    return output;\n  };\n  /**\n   * @param {?} definedInputs\n   * @param {?} userInputs\n   * @return {?}\n   */\n\n\n  OptionBuilder.prototype.onlyOptionsGiven = function (definedInputs, userInputs) {\n    for (var\n    /** @type {?} */\n    i = 0; i < definedInputs.length; i++) {\n      var\n      /** @type {?} */\n      input = definedInputs[i];\n\n      if (input !== 'options' && typeof userInputs[input] !== 'undefined') {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  return OptionBuilder;\n}();\n\nOptionBuilder.decorators = [{\n  type: Injectable\n}];\n/**\n * @nocollapse\n */\n\nOptionBuilder.ctorParameters = function () {\n  return [];\n};\n/**\n *  service for navigator.geolocation methods\n */\n\n\nvar NavigatorGeolocation =\n/** @class */\nfunction () {\n  function NavigatorGeolocation() {}\n  /**\n   * @param {?=} geoLocationOptions\n   * @return {?}\n   */\n\n\n  NavigatorGeolocation.prototype.getCurrentPosition = function (geoLocationOptions) {\n    geoLocationOptions = geoLocationOptions || {\n      timeout: 5000\n    };\n    return new Observable$1(function (responseObserver) {\n      if (navigator.geolocation) {\n        navigator.geolocation.getCurrentPosition(function (position) {\n          responseObserver.next(position);\n          responseObserver.complete();\n        }, function (evt) {\n          return responseObserver.error(evt);\n        }, geoLocationOptions);\n      } else {\n        responseObserver.error('Browser Geolocation service failed.');\n      }\n    });\n  };\n\n  return NavigatorGeolocation;\n}();\n\nNavigatorGeolocation.decorators = [{\n  type: Injectable\n}];\n/**\n * @nocollapse\n */\n\nNavigatorGeolocation.ctorParameters = function () {\n  return [];\n};\n\nvar NG_MAP_CONFIG_TOKEN = new InjectionToken('NG_MAP_CONFIG_TOKEN');\n/**\n * @abstract\n */\n\nvar NgMapApiLoader =\n/** @class */\nfunction () {\n  /**\n   * @param {?} config\n   */\n  function NgMapApiLoader(config) {\n    this.config = config;\n    this.api$ = first$1.call(new ReplaySubject$1(1));\n    this.config = this.config || {\n      apiUrl: 'https://maps.google.com/maps/api/js'\n    };\n  }\n  /**\n   * @abstract\n   * @return {?}\n   */\n\n\n  NgMapApiLoader.prototype.load = function () {};\n  /**\n   * @return {?}\n   */\n\n\n  NgMapApiLoader.prototype.ngOnDestroy = function () {\n    this.api$.complete();\n  };\n\n  return NgMapApiLoader;\n}();\n\nvar NgMapAsyncCallbackApiLoader =\n/** @class */\nfunction (_super) {\n  __extends(NgMapAsyncCallbackApiLoader, _super);\n  /**\n   * @param {?} zone\n   * @param {?} config\n   */\n\n\n  function NgMapAsyncCallbackApiLoader(zone, config) {\n    var _this = _super.call(this, config) || this;\n\n    _this.zone = zone;\n    return _this;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  NgMapAsyncCallbackApiLoader.prototype.load = function () {\n    var _this = this;\n\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    if (isMapsApiLoaded()) {\n      this.api$.next(google.maps);\n    } else if (!document.querySelector('#ngui-map-api')) {\n      window['nguiMapRef'] = window['nguiMapRef'] || [];\n      window['nguiMapRef'].push({\n        zone: this.zone,\n        componentFn: function () {\n          return _this.api$.next(google.maps);\n        }\n      });\n      this.addGoogleMapsApi();\n    }\n  };\n  /**\n   * @return {?}\n   */\n\n\n  NgMapAsyncCallbackApiLoader.prototype.addGoogleMapsApi = function () {\n    window['initNguiMap'] = window['initNguiMap'] || function () {\n      window['nguiMapRef'].forEach(function (nguiMapRef) {\n        nguiMapRef.zone.run(function () {\n          nguiMapRef.componentFn();\n        });\n      });\n      window['nguiMapRef'].splice(0, window['nguiMapRef'].length);\n    };\n\n    var\n    /** @type {?} */\n    script = document.createElement('script');\n    script.id = 'ngui-map-api'; // script.src = \"https://maps.google.com/maps/api/js?callback=initNguiMap\";\n\n    var\n    /** @type {?} */\n    apiUrl = this.config.apiUrl;\n    apiUrl += apiUrl.indexOf('?') !== -1 ? '&' : '?';\n    script.src = apiUrl + 'callback=initNguiMap';\n    document.querySelector('body').appendChild(script);\n  };\n\n  return NgMapAsyncCallbackApiLoader;\n}(NgMapApiLoader);\n\nNgMapAsyncCallbackApiLoader.decorators = [{\n  type: Injectable\n}];\n/**\n * @nocollapse\n */\n\nNgMapAsyncCallbackApiLoader.ctorParameters = function () {\n  return [{\n    type: NgZone\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [NG_MAP_CONFIG_TOKEN]\n    }]\n  }];\n};\n\nvar NgMapAsyncApiLoader =\n/** @class */\nfunction (_super) {\n  __extends(NgMapAsyncApiLoader, _super);\n  /**\n   * @param {?} config\n   */\n\n\n  function NgMapAsyncApiLoader(config) {\n    return _super.call(this, config) || this;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  NgMapAsyncApiLoader.prototype.load = function () {\n    var _this = this;\n\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    if (isMapsApiLoaded()) {\n      this.api$.next(google.maps);\n    } else if (!document.querySelector('#ngui-map-api')) {\n      var\n      /** @type {?} */\n      script = document.createElement('script');\n      script.id = 'ngui-map-api';\n      script.async = true;\n\n      script.onload = function () {\n        return _this.api$.next(google.maps);\n      };\n\n      script.src = this.config.apiUrl;\n      document.querySelector('body').appendChild(script);\n    }\n  };\n\n  return NgMapAsyncApiLoader;\n}(NgMapApiLoader);\n\nNgMapAsyncApiLoader.decorators = [{\n  type: Injectable\n}];\n/**\n * @nocollapse\n */\n\nNgMapAsyncApiLoader.ctorParameters = function () {\n  return [{\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [NG_MAP_CONFIG_TOKEN]\n    }]\n  }];\n};\n/**\n *   Provides [defered/promise API](https://docs.angularjs.org/api/ng/service/$q)\n *   service for Google Geocoder service\n */\n\n\nvar GeoCoder =\n/** @class */\nfunction () {\n  /**\n   * @param {?} apiLoader\n   */\n  function GeoCoder(apiLoader) {\n    this.apiLoader = apiLoader;\n    this.apiLoaderSubs = [];\n  }\n  /**\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  GeoCoder.prototype.geocode = function (options) {\n    var _this = this;\n\n    return new Observable$1(function (responseObserver) {\n      _this.apiLoaderSubs.push(_this.apiLoader.api$.subscribe(function () {\n        return _this.requestGeocode(options, responseObserver);\n      }));\n    });\n  };\n  /**\n   * @return {?}\n   */\n\n\n  GeoCoder.prototype.ngOnDestroy = function () {\n    this.apiLoaderSubs.map(function (sub) {\n      return sub.unsubscribe();\n    });\n  };\n  /**\n   * @param {?} options\n   * @param {?} observer\n   * @return {?}\n   */\n\n\n  GeoCoder.prototype.requestGeocode = function (options, observer) {\n    var\n    /** @type {?} */\n    geocoder = new google.maps.Geocoder();\n    geocoder.geocode(options, function (results, status) {\n      if (status === google.maps.GeocoderStatus.OK) {\n        observer.next(results);\n        observer.complete();\n      } else {\n        observer.error(results);\n      }\n    });\n  };\n\n  return GeoCoder;\n}();\n\nGeoCoder.decorators = [{\n  type: Injectable\n}];\n/**\n * @nocollapse\n */\n\nGeoCoder.ctorParameters = function () {\n  return [{\n    type: NgMapApiLoader\n  }];\n};\n/**\n * collection of map instance-related properties and methods\n */\n\n\nvar NguiMap =\n/** @class */\nfunction () {\n  /**\n   * @param {?} geoCoder\n   * @param {?} optionBuilder\n   * @param {?} zone\n   */\n  function NguiMap(geoCoder, optionBuilder, zone) {\n    var _this = this;\n\n    this.geoCoder = geoCoder;\n    this.optionBuilder = optionBuilder;\n    this.zone = zone;\n\n    this.updateGoogleObject = function (object, changes) {\n      var\n      /** @type {?} */\n      val,\n      /** @type {?} */\n      currentValue,\n      /** @type {?} */\n      setMethodName;\n\n      if (object) {\n        for (var\n        /** @type {?} */\n        key in changes) {\n          setMethodName = \"set\" + key.replace(/^[a-z]/, function (x) {\n            return x.toUpperCase();\n          });\n          currentValue = changes[key].currentValue;\n\n          if (['position', 'center'].indexOf(key) !== -1 && typeof currentValue === 'string') {\n            // To preserve setMethod name in Observable callback, wrap it as a function, then execute\n            (function (setMethodName) {\n              _this.geoCoder.geocode({\n                address: currentValue\n              }).subscribe(function (results) {\n                if (typeof object[setMethodName] === 'function') {\n                  object[setMethodName](results[0].geometry.location);\n                } else {\n                  console.error('Not all options are dynamically updatable according to Googles Maps API V3 documentation.\\n' + 'Please check Google Maps API documentation, and use \"setOptions\" instead.');\n                }\n              });\n            })(setMethodName);\n          } else {\n            val = _this.optionBuilder.googlize(currentValue);\n\n            if (typeof object[setMethodName] === 'function') {\n              object[setMethodName](val);\n            } else {\n              console.error('Not all options are dynamically updatable according to Googles Maps API V3 documentation.\\n' + 'Please check Google Maps API documentation, and use \"setOptions\" instead.');\n            }\n          }\n        }\n      }\n    };\n  }\n  /**\n   * @param {?} definedEvents\n   * @param {?} thisObj\n   * @param {?} prefix\n   * @return {?}\n   */\n\n\n  NguiMap.prototype.setObjectEvents = function (definedEvents, thisObj, prefix) {\n    var _this = this;\n\n    definedEvents.forEach(function (definedEvent) {\n      var\n      /** @type {?} */\n      eventName = _this.getEventName(definedEvent),\n\n      /** @type {?} */\n      zone = _this.zone;\n\n      zone.runOutsideAngular(function () {\n        thisObj[prefix].addListener(eventName, function (event) {\n          var\n          /** @type {?} */\n          param = event ? event : {};\n          param.target = this;\n          zone.run(function () {\n            return thisObj[definedEvent].emit(param);\n          });\n        });\n      });\n    });\n  };\n  /**\n   * @param {?} definedEvents\n   * @param {?} thisObj\n   * @param {?} prefix\n   * @return {?}\n   */\n\n\n  NguiMap.prototype.clearObjectEvents = function (definedEvents, thisObj, prefix) {\n    var _this = this;\n\n    definedEvents.forEach(function (definedEvent) {\n      var\n      /** @type {?} */\n      eventName = _this.getEventName(definedEvent);\n\n      _this.zone.runOutsideAngular(function () {\n        if (thisObj[prefix]) {\n          google.maps.event.clearListeners(thisObj[prefix], eventName);\n        }\n      });\n    });\n\n    if (thisObj[prefix]) {\n      if (thisObj[prefix].setMap) {\n        thisObj[prefix].setMap(null);\n      }\n\n      delete thisObj[prefix].nguiMapComponent;\n      delete thisObj[prefix];\n    }\n  };\n  /**\n   * @param {?} definedEvent\n   * @return {?}\n   */\n\n\n  NguiMap.prototype.getEventName = function (definedEvent) {\n    return definedEvent.replace(/([A-Z])/g, function ($1) {\n      return \"_\" + $1.toLowerCase();\n    }) // positionChanged -> position_changed\n    .replace(/^map_/, ''); // map_click -> click  to avoid DOM conflicts\n  };\n\n  return NguiMap;\n}();\n\nNguiMap.decorators = [{\n  type: Injectable\n}];\n/**\n * @nocollapse\n */\n\nNguiMap.ctorParameters = function () {\n  return [{\n    type: GeoCoder\n  }, {\n    type: OptionBuilder\n  }, {\n    type: NgZone\n  }];\n};\n\nvar INPUTS$1 = ['backgroundColor', 'center', 'disableDefaultUI', 'disableDoubleClickZoom', 'draggable', 'draggableCursor', 'draggingCursor', 'heading', 'keyboardShortcuts', 'mapMaker', 'mapTypeControl', 'mapTypeId', 'maxZoom', 'minZoom', 'noClear', 'overviewMapControl', 'panControl', 'panControlOptions', 'rotateControl', 'scaleControl', 'scrollwheel', 'streetView', 'styles', 'tilt', 'zoom', 'streetViewControl', 'zoomControl', 'zoomControlOptions', 'mapTypeControlOptions', 'overviewMapControlOptions', 'rotateControlOptions', 'scaleControlOptions', 'streetViewControlOptions', 'fullscreenControl', 'fullscreenControlOptions', 'options', // ngui-map-specific inputs\n'geoFallbackCenter'];\nvar OUTPUTS$1 = ['bounds_changed', 'center_changed', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'heading_changed', 'idle', 'typeid_changed', 'mousemove', 'mouseout', 'mouseover', 'projection_changed', 'resize', 'rightclick', 'tilesloaded', 'tile_changed', 'zoom_changed', // to avoid DOM event conflicts\n'mapClick', 'mapMouseover', 'mapMouseout', 'mapMousemove', 'mapDrag', 'mapDragend', 'mapDragstart'];\n\nvar NguiMapComponent =\n/** @class */\nfunction () {\n  /**\n   * @param {?} optionBuilder\n   * @param {?} elementRef\n   * @param {?} geolocation\n   * @param {?} geoCoder\n   * @param {?} nguiMap\n   * @param {?} apiLoader\n   * @param {?} zone\n   */\n  function NguiMapComponent(optionBuilder, elementRef, geolocation, geoCoder, nguiMap, apiLoader, zone) {\n    var _this = this;\n\n    this.optionBuilder = optionBuilder;\n    this.elementRef = elementRef;\n    this.geolocation = geolocation;\n    this.geoCoder = geoCoder;\n    this.nguiMap = nguiMap;\n    this.apiLoader = apiLoader;\n    this.zone = zone;\n    this.mapReady$ = new EventEmitter();\n    this.mapOptions = {};\n    this.inputChanges$ = new Subject$1();\n    this.infoWindows = {};\n    this.mapIdledOnce = false;\n    this.initializeMapAfterDisplayed = false;\n    apiLoader.load(); // all outputs needs to be initialized,\n    // http://stackoverflow.com/questions/37765519/angular2-directive-cannot-read-property-subscribe-of-undefined-with-outputs\n\n    OUTPUTS$1.forEach(function (output) {\n      return _this[output] = new EventEmitter();\n    });\n  }\n  /**\n   * @return {?}\n   */\n\n\n  NguiMapComponent.prototype.ngAfterViewInit = function () {\n    var _this = this;\n\n    this.apiLoaderSub = this.apiLoader.api$.subscribe(function () {\n      return _this.initializeMap();\n    });\n  };\n  /**\n   * @return {?}\n   */\n\n\n  NguiMapComponent.prototype.ngAfterViewChecked = function () {\n    if (this.initializeMapAfterDisplayed && this.el && this.el.offsetWidth > 0) {\n      this.initializeMap();\n    }\n  };\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n\n\n  NguiMapComponent.prototype.ngOnChanges = function (changes) {\n    this.inputChanges$.next(changes);\n  };\n  /**\n   * @return {?}\n   */\n\n\n  NguiMapComponent.prototype.initializeMap = function () {\n    var _this = this;\n\n    this.el = this.elementRef.nativeElement.querySelector('.google-map');\n\n    if (this.el && this.el.offsetWidth === 0) {\n      this.initializeMapAfterDisplayed = true;\n      return;\n    }\n\n    this.initializeMapAfterDisplayed = false;\n    this.mapOptions = this.optionBuilder.googlizeAllInputs(INPUTS$1, this);\n    this.mapOptions.zoom = this.mapOptions.zoom || 15;\n    typeof this.mapOptions.center === 'string' && delete this.mapOptions.center;\n    this.zone.runOutsideAngular(function () {\n      _this.map = new google.maps.Map(_this.el, _this.mapOptions);\n      _this.map['mapObjectName'] = 'NguiMapComponent';\n\n      if (!_this.mapOptions.center) {\n        _this.setCenter();\n      } // set google events listeners and emits to this outputs listeners\n\n\n      _this.nguiMap.setObjectEvents(OUTPUTS$1, _this, 'map');\n\n      _this.map.addListener('idle', function () {\n        if (!_this.mapIdledOnce) {\n          _this.mapIdledOnce = true;\n          setTimeout(function () {\n            _this.mapReady$.emit(_this.map);\n          });\n        }\n      }); // update map when input changes\n\n\n      debounceTime$1.call(_this.inputChanges$, 1000).subscribe(function (changes) {\n        return _this.nguiMap.updateGoogleObject(_this.map, changes);\n      });\n\n      if (typeof window !== 'undefined' && window['nguiMapRef']) {\n        // expose map object for test and debugging on (<any>window)\n        window['nguiMapRef'].map = _this.map;\n      }\n    });\n  };\n  /**\n   * @return {?}\n   */\n\n\n  NguiMapComponent.prototype.setCenter = function () {\n    var _this = this;\n\n    if (!this['center']) {\n      this.geolocation.getCurrentPosition().subscribe(function (position) {\n        var\n        /** @type {?} */\n        latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n\n        _this.map.setCenter(latLng);\n      }, function (error) {\n        console.error('ngui-map: Error finding the current position');\n\n        _this.map.setCenter(_this.mapOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n      });\n    } else if (typeof this['center'] === 'string') {\n      this.geoCoder.geocode({\n        address: this['center']\n      }).subscribe(function (results) {\n        _this.map.setCenter(results[0].geometry.location);\n      }, function (error) {\n        _this.map.setCenter(_this.mapOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n      });\n    }\n  };\n  /**\n   * @param {?} id\n   * @param {?} anchor\n   * @return {?}\n   */\n\n\n  NguiMapComponent.prototype.openInfoWindow = function (id, anchor) {\n    this.infoWindows[id].open(anchor);\n  };\n  /**\n   * @param {?} id\n   * @return {?}\n   */\n\n\n  NguiMapComponent.prototype.closeInfoWindow = function (id) {\n    // if infoWindow for id exists, close the infoWindow\n    if (this.infoWindows[id]) this.infoWindows[id].close();\n  };\n  /**\n   * @return {?}\n   */\n\n\n  NguiMapComponent.prototype.ngOnDestroy = function () {\n    this.inputChanges$.complete();\n\n    if (this.el && !this.initializeMapAfterDisplayed) {\n      this.nguiMap.clearObjectEvents(OUTPUTS$1, this, 'map');\n    }\n\n    if (this.apiLoaderSub) {\n      this.apiLoaderSub.unsubscribe();\n    }\n  };\n  /**\n   * @param {?} mapObjectName\n   * @param {?} mapObject\n   * @return {?}\n   */\n\n\n  NguiMapComponent.prototype.addToMapObjectGroup = function (mapObjectName, mapObject) {\n    var\n    /** @type {?} */\n    groupName = toCamelCase(mapObjectName.toLowerCase()) + 's'; // e.g. markers\n\n    this.map[groupName] = this.map[groupName] || [];\n    this.map[groupName].push(mapObject);\n  };\n  /**\n   * @param {?} mapObjectName\n   * @param {?} mapObject\n   * @return {?}\n   */\n\n\n  NguiMapComponent.prototype.removeFromMapObjectGroup = function (mapObjectName, mapObject) {\n    var\n    /** @type {?} */\n    groupName = toCamelCase(mapObjectName.toLowerCase()) + 's'; // e.g. markers\n\n    if (this.map && this.map[groupName]) {\n      var\n      /** @type {?} */\n      index = this.map[groupName].indexOf(mapObject);\n      index > -1 && this.map[groupName].splice(index, 1);\n    }\n  };\n\n  return NguiMapComponent;\n}();\n\nNguiMapComponent.decorators = [{\n  type: Component,\n  args: [{\n    selector: 'ngui-map',\n    providers: [NguiMap, OptionBuilder, GeoCoder, NavigatorGeolocation],\n    styles: [\"\\n    ngui-map {display: block; height: 300px;}\\n    .google-map {width: 100%; height: 100%}\\n  \"],\n    inputs: INPUTS$1,\n    outputs: OUTPUTS$1,\n    encapsulation: ViewEncapsulation.None,\n    template: \"\\n    <div class=\\\"google-map\\\"></div>\\n    <ng-content></ng-content>\\n  \"\n  }]\n}];\n/**\n * @nocollapse\n */\n\nNguiMapComponent.ctorParameters = function () {\n  return [{\n    type: OptionBuilder\n  }, {\n    type: ElementRef\n  }, {\n    type: NavigatorGeolocation\n  }, {\n    type: GeoCoder\n  }, {\n    type: NguiMap\n  }, {\n    type: NgMapApiLoader\n  }, {\n    type: NgZone\n  }];\n};\n\nNguiMapComponent.propDecorators = {\n  'mapReady$': [{\n    type: Output\n  }]\n};\nvar INPUTS = [];\nvar OUTPUTS = [];\n\nvar BicyclingLayer =\n/** @class */\nfunction (_super) {\n  __extends(BicyclingLayer, _super);\n  /**\n   * @param {?} nguiMapComp\n   */\n\n\n  function BicyclingLayer(nguiMapComp) {\n    return _super.call(this, nguiMapComp, 'BicyclingLayer', INPUTS, OUTPUTS) || this;\n  }\n\n  return BicyclingLayer;\n}(BaseMapDirective);\n\nBicyclingLayer.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map > bicycling-layer',\n    inputs: INPUTS,\n    outputs: OUTPUTS\n  }]\n}];\n/**\n * @nocollapse\n */\n\nBicyclingLayer.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }];\n};\n\nvar INPUTS$2 = ['content', 'disableAutoPan', 'maxWidth', 'pixelOffset', 'position', 'zIndex', 'options'];\nvar OUTPUTS$2 = ['closeclick', 'content_changed', 'domready', 'position_changed', 'zindex_changed'];\n\nvar InfoWindow =\n/** @class */\nfunction () {\n  /**\n   * @param {?} elementRef\n   * @param {?} nguiMap\n   * @param {?} nguiMapComponent\n   */\n  function InfoWindow(elementRef, nguiMap, nguiMapComponent) {\n    var _this = this;\n\n    this.elementRef = elementRef;\n    this.nguiMap = nguiMap;\n    this.nguiMapComponent = nguiMapComponent;\n    this.initialized$ = new EventEmitter();\n    this.objectOptions = {};\n    this.inputChanges$ = new Subject$1();\n    this.elementRef.nativeElement.style.display = 'none';\n    OUTPUTS$2.forEach(function (output) {\n      return _this[output] = new EventEmitter();\n    });\n  }\n  /**\n   * @return {?}\n   */\n\n\n  InfoWindow.prototype.ngOnInit = function () {\n    var _this = this;\n\n    if (this.nguiMapComponent.mapIdledOnce) {\n      this.initialize();\n    } else {\n      this.nguiMapComponent.mapReady$.subscribe(function (map) {\n        return _this.initialize();\n      });\n    }\n  };\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n\n\n  InfoWindow.prototype.ngOnChanges = function (changes) {\n    this.inputChanges$.next(changes);\n  };\n  /**\n   * @return {?}\n   */\n\n\n  InfoWindow.prototype.initialize = function () {\n    var _this = this;\n\n    this.objectOptions = this.nguiMapComponent.optionBuilder.googlizeAllInputs(INPUTS$2, this);\n    this.infoWindow = new google.maps.InfoWindow(this.objectOptions);\n    this.infoWindow['mapObjectName'] = 'InfoWindow'; // register infoWindow ids to NguiMap, so that it can be opened by id\n\n    if (this.elementRef.nativeElement.id) {\n      this.nguiMapComponent.infoWindows[this.elementRef.nativeElement.id] = this;\n    } else {\n      console.error('An InfoWindow must have an id. e.g. id=\"detail\"');\n    } // set google events listeners and emits to this outputs listeners\n\n\n    this.nguiMap.setObjectEvents(OUTPUTS$2, this, 'infoWindow'); // update object when input changes\n\n    debounceTime$1.call(this.inputChanges$, 1000).subscribe(function (changes) {\n      return _this.nguiMap.updateGoogleObject(_this.infoWindow, changes);\n    });\n    this.nguiMapComponent.addToMapObjectGroup('InfoWindow', this.infoWindow);\n    this.initialized$.emit(this.infoWindow);\n  };\n  /**\n   * @param {?} anchor\n   * @return {?}\n   */\n\n\n  InfoWindow.prototype.open = function (anchor) {\n    // set content and open it\n    this.infoWindow.setContent(this.template.element.nativeElement);\n    this.infoWindow.open(this.nguiMapComponent.map, anchor);\n  };\n  /**\n   * @return {?}\n   */\n\n\n  InfoWindow.prototype.close = function () {\n    // check if infoWindow exists, and closes it\n    if (this.infoWindow) this.infoWindow.close();\n  };\n  /**\n   * @return {?}\n   */\n\n\n  InfoWindow.prototype.ngOnDestroy = function () {\n    this.inputChanges$.complete();\n\n    if (this.infoWindow) {\n      this.nguiMap.clearObjectEvents(OUTPUTS$2, this, 'infoWindow');\n      delete this.infoWindow;\n    }\n  };\n\n  return InfoWindow;\n}();\n\nInfoWindow.decorators = [{\n  type: Component,\n  args: [{\n    selector: 'ngui-map > info-window',\n    inputs: INPUTS$2,\n    outputs: OUTPUTS$2,\n    template: \"<div #template><ng-content></ng-content></div>\"\n  }]\n}];\n/**\n * @nocollapse\n */\n\nInfoWindow.ctorParameters = function () {\n  return [{\n    type: ElementRef\n  }, {\n    type: NguiMap\n  }, {\n    type: NguiMapComponent\n  }];\n};\n\nInfoWindow.propDecorators = {\n  'initialized$': [{\n    type: Output\n  }],\n  'template': [{\n    type: ViewChild,\n    args: ['template', {\n      read: ViewContainerRef\n    }]\n  }]\n};\nvar INPUTS$3 = ['position']; // to avoid DOM event conflicts map_*\n\nvar OUTPUTS$3 = ['animationChanged', 'click', 'clickableChanged', 'cursorChanged', 'dblclick', 'drag', 'dragend', 'draggableChanged', 'dragstart', 'flatChanged', 'iconChanged', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'positionChanged', 'rightclick', 'shapeChanged', 'titleChanged', 'visibleChanged', 'zindexChanged', 'map_click', 'map_mouseover', 'map_mouseout', 'map_mouseup', 'map_mousedown', 'map_drag', 'map_dragend'];\n/**\n * Wrapper to a create extend OverlayView at runtime, only after google maps is loaded.\n * Otherwise throws a google is unknown error.\n * @param {?} htmlEl\n * @param {?} position\n * @return {?}\n */\n\nfunction getCustomMarkerOverlayView(htmlEl, position) {\n  var CustomMarkerOverlayView =\n  /** @class */\n  function (_super) {\n    __extends(CustomMarkerOverlayView, _super);\n    /**\n     * @param {?} htmlEl\n     * @param {?} position\n     */\n\n\n    function CustomMarkerOverlayView(htmlEl, position) {\n      var _this = _super.call(this) || this;\n\n      _this.visible = true;\n\n      _this.setPosition = function (position) {\n        _this.htmlEl.style.visibility = 'hidden';\n\n        if (position.constructor.name === 'Array') {\n          _this.position = new google.maps.LatLng(position[0], position[1]);\n        } else if (typeof position === 'string') {\n          var\n          /** @type {?} */\n          geocoder = new google.maps.Geocoder();\n          geocoder.geocode({\n            address: position\n          }, function (results, status) {\n            if (status === google.maps.GeocoderStatus.OK) {\n              _this.setPosition(results[0].geometry.location);\n            } else {}\n          });\n        } else if (position && typeof position.lng === 'function') {\n          _this.position = position;\n        }\n\n        if (_this.getProjection() && typeof _this.position.lng === 'function') {\n          var\n          /** @type {?} */\n          positionOnMap_1 = function () {\n            var\n            /** @type {?} */\n            posPixel = _this.getProjection().fromLatLngToDivPixel(_this.position);\n\n            var\n            /** @type {?} */\n            x = Math.round(posPixel.x - _this.htmlEl.offsetWidth / 2);\n            var\n            /** @type {?} */\n            y = Math.round(posPixel.y - _this.htmlEl.offsetHeight / 2);\n            _this.htmlEl.style.left = x + 'px';\n            _this.htmlEl.style.top = y + 'px';\n            _this.htmlEl.style.visibility = 'visible';\n          };\n\n          if (_this.htmlEl.offsetWidth && _this.htmlEl.offsetHeight) {\n            positionOnMap_1();\n          } else {\n            setTimeout(function () {\n              return positionOnMap_1();\n            });\n          }\n        }\n      };\n\n      _this.htmlEl = htmlEl;\n      _this.position = position;\n      return _this;\n    }\n    /**\n     * @return {?}\n     */\n\n\n    CustomMarkerOverlayView.prototype.onAdd = function () {\n      this.getPanes().overlayMouseTarget.appendChild(this.htmlEl); // required for correct display inside google maps container\n\n      this.htmlEl.style.position = 'absolute';\n    };\n    /**\n     * @return {?}\n     */\n\n\n    CustomMarkerOverlayView.prototype.draw = function () {\n      this.setPosition(this.position);\n      this.setZIndex(this.zIndex);\n      this.setVisible(this.visible);\n    };\n    /**\n     * @return {?}\n     */\n\n\n    CustomMarkerOverlayView.prototype.onRemove = function () {//\n    };\n    /**\n     * @return {?}\n     */\n\n\n    CustomMarkerOverlayView.prototype.getPosition = function () {\n      return this.position;\n    };\n    /**\n     * @param {?} zIndex\n     * @return {?}\n     */\n\n\n    CustomMarkerOverlayView.prototype.setZIndex = function (zIndex) {\n      zIndex && (this.zIndex = zIndex);\n      /* jshint ignore:line */\n\n      this.htmlEl.style.zIndex = this.zIndex;\n    };\n    /**\n     * @param {?} visible\n     * @return {?}\n     */\n\n\n    CustomMarkerOverlayView.prototype.setVisible = function (visible) {\n      this.htmlEl.style.display = visible ? 'inline-block' : 'none';\n      this.visible = visible;\n    };\n\n    return CustomMarkerOverlayView;\n  }(google.maps.OverlayView);\n\n  return new CustomMarkerOverlayView(htmlEl, position);\n}\n\nvar CustomMarker =\n/** @class */\nfunction () {\n  /**\n   * @param {?} nguiMapComponent\n   * @param {?} elementRef\n   * @param {?} nguiMap\n   */\n  function CustomMarker(nguiMapComponent, elementRef, nguiMap) {\n    var _this = this;\n\n    this.nguiMapComponent = nguiMapComponent;\n    this.elementRef = elementRef;\n    this.nguiMap = nguiMap;\n    this.initialized$ = new EventEmitter();\n    this.inputChanges$ = new Subject$1();\n    this.elementRef.nativeElement.style.display = 'none';\n    OUTPUTS$3.forEach(function (output) {\n      return _this[output] = new EventEmitter();\n    });\n  }\n  /**\n   * @return {?}\n   */\n\n\n  CustomMarker.prototype.ngOnInit = function () {\n    var _this = this;\n\n    if (this.nguiMapComponent.mapIdledOnce) {\n      this.initialize();\n    } else {\n      this.nguiMapComponent.mapReady$.subscribe(function (map) {\n        return _this.initialize();\n      });\n    }\n  };\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n\n\n  CustomMarker.prototype.ngOnChanges = function (changes) {\n    this.inputChanges$.next(changes);\n  };\n  /**\n   * @return {?}\n   */\n\n\n  CustomMarker.prototype.ngOnDestroy = function () {\n    this.inputChanges$.complete();\n    this.nguiMapComponent.removeFromMapObjectGroup('CustomMarker', this.mapObject);\n\n    if (this.mapObject) {\n      this.nguiMap.clearObjectEvents(OUTPUTS$3, this, 'mapObject');\n    }\n  };\n  /**\n   * @return {?}\n   */\n\n\n  CustomMarker.prototype.initialize = function () {\n    var _this = this;\n\n    this.el = this.elementRef.nativeElement;\n    this.mapObject = getCustomMarkerOverlayView(this.el, this['position']);\n    this.mapObject.setMap(this.nguiMapComponent.map); // set google events listeners and emits to this outputs listeners\n\n    this.nguiMap.setObjectEvents(OUTPUTS$3, this, 'mapObject'); // update object when input changes\n\n    debounceTime$1.call(this.inputChanges$, 1000).subscribe(function (changes) {\n      return _this.nguiMap.updateGoogleObject(_this.mapObject, changes);\n    });\n    this.nguiMapComponent.addToMapObjectGroup('CustomMarker', this.mapObject);\n    this.initialized$.emit(this.mapObject);\n  };\n\n  return CustomMarker;\n}();\n\nCustomMarker.decorators = [{\n  type: Component,\n  args: [{\n    selector: 'ngui-map > custom-marker',\n    inputs: INPUTS$3,\n    outputs: OUTPUTS$3,\n    template: \"\\n    <ng-content></ng-content>\\n  \"\n  }]\n}];\n/**\n * @nocollapse\n */\n\nCustomMarker.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }, {\n    type: ElementRef\n  }, {\n    type: NguiMap\n  }];\n};\n\nCustomMarker.propDecorators = {\n  'initialized$': [{\n    type: Output\n  }]\n};\nvar INPUTS$4 = ['center', 'clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'map', 'radius', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'options', // ngui-map specific inputs\n'geoFallbackCenter'];\nvar OUTPUTS$4 = ['centerChanged', 'click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'radiusChanged', 'rightclick'];\n\nvar Circle =\n/** @class */\nfunction (_super) {\n  __extends(Circle, _super);\n  /**\n   * @param {?} nguiMapComp\n   */\n\n\n  function Circle(nguiMapComp) {\n    var _this = _super.call(this, nguiMapComp, 'Circle', INPUTS$4, OUTPUTS$4) || this;\n\n    _this.nguiMapComp = nguiMapComp;\n    _this.objectOptions = {};\n    return _this;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  Circle.prototype.initialize = function () {\n    _super.prototype.initialize.call(this);\n\n    this.setCenter();\n  };\n  /**\n   * @return {?}\n   */\n\n\n  Circle.prototype.setCenter = function () {\n    var _this = this;\n\n    if (!this['center']) {\n      this._subscriptions.push(this.nguiMapComp.geolocation.getCurrentPosition().subscribe(function (center) {\n        var\n        /** @type {?} */\n        latLng = new google.maps.LatLng(center.coords.latitude, center.coords.longitude);\n\n        _this.mapObject.setCenter(latLng);\n      }, function (error) {\n        console.error('ngui-map, error in finding the current position');\n\n        _this.mapObject.setCenter(_this.objectOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n      }));\n    } else if (typeof this['center'] === 'string') {\n      this._subscriptions.push(this.nguiMapComp.geoCoder.geocode({\n        address: this['center']\n      }).subscribe(function (results) {\n        _this.mapObject.setCenter(results[0].geometry.location);\n      }, function (error) {\n        console.error('ngui-map, error in finding location from', _this['center']);\n\n        _this.mapObject.setCenter(_this.objectOptions['geoFallbackCenter'] || new google.maps.LatLng(0, 0));\n      }));\n    }\n  };\n\n  return Circle;\n}(BaseMapDirective);\n\nCircle.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map>circle, ngui-map>map-circle',\n    inputs: INPUTS$4,\n    outputs: OUTPUTS$4\n  }]\n}];\n/**\n * @nocollapse\n */\n\nCircle.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }];\n};\n\nvar INPUTS$5 = ['controlPosition', 'controls', 'drawingMode', 'featureFactory', 'style', 'geoJson', 'geoJsonUrl'];\nvar OUTPUTS$5 = ['addfeature', 'click', 'dblclick', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'removefeature', 'removeproperty', 'rightclick', 'setgeometry', 'setproperty'];\n\nvar DataLayer =\n/** @class */\nfunction (_super) {\n  __extends(DataLayer, _super);\n  /**\n   * @param {?} nguiMapComponent\n   */\n\n\n  function DataLayer(nguiMapComponent) {\n    return _super.call(this, nguiMapComponent, 'Data', INPUTS$5, OUTPUTS$5) || this;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  DataLayer.prototype.initialize = function () {\n    if (this['geoJson']) {\n      // addGeoJson from an object\n      this.nguiMapComponent.map.data.addGeoJson(this['geoJson']);\n    } else if (this['geoJsonUrl']) {\n      // loadGeoJson from a URL\n      this.nguiMapComponent.map.data.loadGeoJson(this['geoJsonUrl']);\n    } else {\n      this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n      this.nguiMapComponent.map.data.add(this.objectOptions);\n    } // unlike others, data belongs to map. e.g., map.data.loadGeoJson(), map.data.add()\n\n\n    this.mapObject = this.nguiMapComponent.map.data; // set google events listeners and emits to this outputs listeners\n\n    this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n    this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n    this.initialized$.emit(this.mapObject);\n  };\n\n  return DataLayer;\n}(BaseMapDirective);\n\nDataLayer.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map > data-layer',\n    inputs: INPUTS$5,\n    outputs: OUTPUTS$5\n  }]\n}];\n/**\n * @nocollapse\n */\n\nDataLayer.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }];\n};\n\nvar INPUTS$6 = ['directions', 'draggable', 'hideRouteList', 'infoWindow', 'panel', 'markerOptions', 'polylineOptions', 'preserveViewport', 'routeIndex', 'suppressBicyclingLayer', 'suppressInfoWindows', 'suppressMarkers', 'suppressPolylines'];\nvar OUTPUTS$6 = ['directions_changed'];\n\nvar DirectionsRenderer =\n/** @class */\nfunction (_super) {\n  __extends(DirectionsRenderer, _super);\n  /**\n   * @param {?} nguiMapComponent\n   * @param {?} geolocation\n   */\n\n\n  function DirectionsRenderer(nguiMapComponent, geolocation) {\n    var _this = _super.call(this, nguiMapComponent, 'DirectionsRenderer', INPUTS$6, OUTPUTS$6) || this;\n\n    _this.geolocation = geolocation;\n    return _this;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  DirectionsRenderer.prototype.initialize = function () {\n    this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n\n    if (typeof this.objectOptions['panel'] === 'string') {\n      this.objectOptions['panel'] = document.querySelector(this.objectOptions['panel']);\n    }\n\n    this.directionsService = new google.maps.DirectionsService();\n    this.directionsRenderer = new google.maps.DirectionsRenderer(this.objectOptions);\n    this.directionsRenderer.setMap(this.nguiMapComponent.map); // set google events listeners and emidirectionsRenderer to this outputs listeners\n\n    this.showDirections(this.directionsRequest);\n    this.nguiMap.setObjectEvents(this.outputs, this, 'directionsRenderer');\n    this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n    this.initialized$.emit(this.directionsRenderer);\n  };\n  /**\n   * @param {?} changes\n   * @return {?}\n   */\n\n\n  DirectionsRenderer.prototype.ngOnChanges = function (changes) {\n    var\n    /** @type {?} */\n    newOptions = {};\n\n    for (var\n    /** @type {?} */\n    key in changes) {\n      if (this.inputs.indexOf(key) !== -1) {\n        newOptions[key] = this.optionBuilder.googlize(changes[key].currentValue);\n      }\n    }\n\n    if (changes['directionsRequest'] && this.directionsRenderer) {\n      this.directionsService && this.showDirections(this.directionsRequest);\n    }\n  };\n  /**\n   * @param {?} directionsRequest\n   * @return {?}\n   */\n\n\n  DirectionsRenderer.prototype.showDirections = function (directionsRequest) {\n    var _this = this;\n\n    this.directionsService.route(directionsRequest, function (response, status) {\n      // in some-case the callback is called during destroy component,\n      // we should make sure directionsRenderer is still defined (cancelling `route` callback is not possible).\n      if (!_this.directionsRenderer) {\n        return;\n      }\n\n      if (status === google.maps.DirectionsStatus.OK) {\n        _this.directionsRenderer.setDirections(response);\n      } else {\n        console.error('Directions request failed due to ' + status);\n      }\n    });\n  };\n  /**\n   * @return {?}\n   */\n\n\n  DirectionsRenderer.prototype.ngOnDestroy = function () {\n    _super.prototype.ngOnDestroy.call(this);\n\n    this.nguiMap.clearObjectEvents(this.outputs, this, 'directionsRenderer');\n  };\n\n  return DirectionsRenderer;\n}(BaseMapDirective);\n\nDirectionsRenderer.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map > directions-renderer',\n    inputs: INPUTS$6,\n    outputs: OUTPUTS$6\n  }]\n}];\n/**\n * @nocollapse\n */\n\nDirectionsRenderer.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }, {\n    type: NavigatorGeolocation\n  }];\n};\n\nDirectionsRenderer.propDecorators = {\n  'directionsRequest': [{\n    type: Input,\n    args: ['directions-request']\n  }]\n};\nvar INPUTS$7 = ['options', 'circleOptions', 'drawingControl', 'drawingControlOptions', 'drawingMode', 'map', 'markerOptions', 'polygonOptions', 'polylineOptions', 'rectangleOptions'];\nvar OUTPUTS$7 = ['circlecomplete', 'markercomplete', 'overlaycomplete', 'polygoncomplete', 'polylinecomplete', 'rectanglecomplete'];\n\nvar DrawingManager =\n/** @class */\nfunction (_super) {\n  __extends(DrawingManager, _super);\n  /**\n   * @param {?} nguiMapComp\n   */\n\n\n  function DrawingManager(nguiMapComp) {\n    var _this = _super.call(this, nguiMapComp, 'DrawingManager', INPUTS$7, OUTPUTS$7) || this;\n\n    _this.libraryName = 'drawing';\n    return _this;\n  }\n\n  return DrawingManager;\n}(BaseMapDirective);\n\nDrawingManager.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map > drawing-manager',\n    inputs: INPUTS$7,\n    outputs: OUTPUTS$7\n  }]\n}];\n/**\n * @nocollapse\n */\n\nDrawingManager.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }];\n};\n\nvar INPUTS$8 = ['url', 'bounds', 'clickable', 'opacity'];\nvar OUTPUTS$8 = ['click', 'dblclick'];\n\nvar GroundOverlay =\n/** @class */\nfunction (_super) {\n  __extends(GroundOverlay, _super);\n  /**\n   * @param {?} nguiMapComp\n   */\n\n\n  function GroundOverlay(nguiMapComp) {\n    var _this = _super.call(this, nguiMapComp, 'GroundOverlay', INPUTS$8, OUTPUTS$8) || this;\n\n    _this.objectOptions = {};\n    return _this;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  GroundOverlay.prototype.initialize = function () {\n    // url, bounds are not the options of GroundOverlay\n    this.objectOptions = this.optionBuilder.googlizeAllInputs(['clickable', 'opacity'], this); // noinspection TypeScriptUnresolvedFunction\n\n    this.mapObject = new google.maps.GroundOverlay(this['url'], this['bounds'], this.objectOptions);\n    this.mapObject.setMap(this.nguiMapComponent.map);\n    this.mapObject['mapObjectName'] = this.mapObjectName; // set google events listeners and emits to this outputs listeners\n\n    this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n    this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n    this.initialized$.emit(this.mapObject);\n  };\n\n  return GroundOverlay;\n}(BaseMapDirective);\n\nGroundOverlay.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map > ground-overlay',\n    inputs: INPUTS$8,\n    outputs: OUTPUTS$8\n  }]\n}];\n/**\n * @nocollapse\n */\n\nGroundOverlay.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }];\n};\n\nvar INPUTS$9 = ['data', 'dissipating', 'gradient', 'maxIntensity', 'opacity', 'radius', 'options'];\nvar OUTPUTS$9 = [];\n\nvar HeatmapLayer =\n/** @class */\nfunction (_super) {\n  __extends(HeatmapLayer, _super);\n  /**\n   * @param {?} nguiMapComp\n   */\n\n\n  function HeatmapLayer(nguiMapComp) {\n    var _this = _super.call(this, nguiMapComp, 'HeatmapLayer', INPUTS$9, OUTPUTS$9) || this;\n\n    _this.libraryName = 'visualization';\n    return _this;\n  }\n\n  return HeatmapLayer;\n}(BaseMapDirective);\n\nHeatmapLayer.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map > heatmap-layer',\n    inputs: INPUTS$9,\n    outputs: OUTPUTS$9\n  }]\n}];\n/**\n * @nocollapse\n */\n\nHeatmapLayer.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }];\n};\n\nvar INPUTS$10 = ['clickable', 'preserveViewport', 'screenOverlays', 'suppressInfoWindows', 'url', 'zIndex', 'options'];\nvar OUTPUTS$10 = ['click', 'defaultviewport_changed', 'status_changed'];\n\nvar KmlLayer =\n/** @class */\nfunction (_super) {\n  __extends(KmlLayer, _super);\n  /**\n   * @param {?} nguiMapComp\n   */\n\n\n  function KmlLayer(nguiMapComp) {\n    return _super.call(this, nguiMapComp, 'KmlLayer', INPUTS$10, OUTPUTS$10) || this;\n  }\n\n  return KmlLayer;\n}(BaseMapDirective);\n\nKmlLayer.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map > kml-layer',\n    inputs: INPUTS$10,\n    outputs: OUTPUTS$10\n  }]\n}];\n/**\n * @nocollapse\n */\n\nKmlLayer.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }];\n};\n\nvar INPUTS$11 = ['anchorPoint', 'animation', 'clickable', 'cursor', 'draggable', 'icon', 'label', 'opacity', 'optimized', 'place', 'position', 'shape', 'title', 'visible', 'zIndex', 'options', // ngui-map specific inputs\n'geoFallbackPosition'];\nvar OUTPUTS$11 = ['animationChanged', 'click', 'clickableChanged', 'cursorChanged', 'dblclick', 'drag', 'dragend', 'draggableChanged', 'dragstart', 'flatChanged', 'iconChanged', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'positionChanged', 'rightclick', 'shapeChanged', 'titleChanged', 'visibleChanged', 'zindexChanged'];\n\nvar Marker =\n/** @class */\nfunction (_super) {\n  __extends(Marker, _super);\n  /**\n   * @param {?} nguiMapComp\n   */\n\n\n  function Marker(nguiMapComp) {\n    var _this = _super.call(this, nguiMapComp, 'Marker', INPUTS$11, OUTPUTS$11) || this;\n\n    _this.nguiMapComp = nguiMapComp;\n    _this.objectOptions = {};\n    return _this;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  Marker.prototype.ngOnInit = function () {\n    var _this = this;\n\n    if (this.nguiMapComponent.mapIdledOnce) {\n      this.initialize();\n    } else {\n      this.nguiMapComponent.mapReady$.subscribe(function (map) {\n        return _this.initialize();\n      });\n    }\n  };\n  /**\n   * @return {?}\n   */\n\n\n  Marker.prototype.initialize = function () {\n    _super.prototype.initialize.call(this);\n\n    this.setPosition();\n  };\n  /**\n   * @return {?}\n   */\n\n\n  Marker.prototype.setPosition = function () {\n    var _this = this;\n\n    if (!this['position']) {\n      this._subscriptions.push(this.nguiMapComp.geolocation.getCurrentPosition().subscribe(function (position) {\n        var\n        /** @type {?} */\n        latLng = new google.maps.LatLng(position.coords.latitude, position.coords.longitude);\n\n        _this.mapObject.setPosition(latLng);\n      }, function (error) {\n        console.error('ngui-map, error finding the current location');\n\n        _this.mapObject.setPosition(_this.objectOptions['geoFallbackPosition'] || new google.maps.LatLng(0, 0));\n      }));\n    } else if (typeof this['position'] === 'string') {\n      this._subscriptions.push(this.nguiMapComp.geoCoder.geocode({\n        address: this['position']\n      }).subscribe(function (results) {\n        _this.mapObject.setPosition(results[0].geometry.location);\n      }, function (error) {\n        console.error('ngui-map, error finding the location from', _this['position']);\n\n        _this.mapObject.setPosition(_this.objectOptions['geoFallbackPosition'] || new google.maps.LatLng(0, 0));\n      }));\n    }\n  };\n\n  return Marker;\n}(BaseMapDirective);\n\nMarker.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map > marker',\n    inputs: INPUTS$11,\n    outputs: OUTPUTS$11\n  }]\n}];\n/**\n * @nocollapse\n */\n\nMarker.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }];\n};\n\nvar PlacesAutoComplete =\n/** @class */\nfunction () {\n  /**\n   * @param {?} optionBuilder\n   * @param {?} elementRef\n   * @param {?} apiLoader\n   */\n  function PlacesAutoComplete(optionBuilder, elementRef, apiLoader) {\n    var _this = this;\n\n    this.optionBuilder = optionBuilder;\n    this.elementRef = elementRef;\n    this.apiLoader = apiLoader;\n    this.place_changed = new EventEmitter();\n    this.initialized$ = new EventEmitter(); // only called when map is ready\n\n    this.initialize = function () {\n      _this.objectOptions = _this.optionBuilder.googlizeAllInputs(['bounds', 'componentRestrictions', 'types'], _this);\n\n      if (!google.maps.places) {\n        throw missingLibraryError('PlacesAutoComplete', 'places');\n      }\n\n      _this.autocomplete = new google.maps.places.Autocomplete(_this.elementRef.nativeElement, _this.objectOptions);\n\n      _this.autocomplete.addListener('place_changed', function (place) {\n        _this.place_changed.emit(_this.autocomplete.getPlace());\n      });\n\n      _this.initialized$.emit(_this.autocomplete);\n    };\n\n    apiLoader.load();\n    apiLoader.api$.subscribe(function () {\n      return _this.initialize();\n    });\n  }\n\n  return PlacesAutoComplete;\n}();\n\nPlacesAutoComplete.decorators = [{\n  type: Directive,\n  args: [{\n    selector: '[places-auto-complete]'\n  }]\n}];\n/**\n * @nocollapse\n */\n\nPlacesAutoComplete.ctorParameters = function () {\n  return [{\n    type: OptionBuilder\n  }, {\n    type: ElementRef\n  }, {\n    type: NgMapApiLoader\n  }];\n};\n\nPlacesAutoComplete.propDecorators = {\n  'bounds': [{\n    type: Input,\n    args: ['bounds']\n  }],\n  'componentRestrictions': [{\n    type: Input,\n    args: ['componentRestrictions']\n  }],\n  'types': [{\n    type: Input,\n    args: ['types']\n  }],\n  'place_changed': [{\n    type: Output,\n    args: ['place_changed']\n  }],\n  'initialized$': [{\n    type: Output\n  }]\n};\nvar INPUTS$12 = ['clickable', 'draggable', 'editable', 'fillColor', 'fillOpacity', 'geodesic', 'paths', 'strokeColor', 'strokeOpacity', 'strokePosition', 'strokeWeight', 'visible', 'zIndex', 'options'];\nvar OUTPUTS$12 = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];\n\nvar Polygon =\n/** @class */\nfunction (_super) {\n  __extends(Polygon, _super);\n  /**\n   * @param {?} nguiMapComp\n   */\n\n\n  function Polygon(nguiMapComp) {\n    return _super.call(this, nguiMapComp, 'Polygon', INPUTS$12, OUTPUTS$12) || this;\n  }\n\n  return Polygon;\n}(BaseMapDirective);\n\nPolygon.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map>polygon, ngui-map>map-polygon',\n    inputs: INPUTS$12,\n    outputs: OUTPUTS$12\n  }]\n}];\n/**\n * @nocollapse\n */\n\nPolygon.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }];\n};\n\nvar INPUTS$13 = ['clickable', 'draggable', 'editable', 'geodesic', 'icons', 'path', 'strokeColor', 'strokeOpacity', 'strokeWeight', 'visible', 'zIndex', 'options'];\nvar OUTPUTS$13 = ['click', 'dblclick', 'drag', 'dragend', 'dragstart', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'rightclick'];\n\nvar Polyline =\n/** @class */\nfunction (_super) {\n  __extends(Polyline, _super);\n  /**\n   * @param {?} nguiMapComp\n   */\n\n\n  function Polyline(nguiMapComp) {\n    return _super.call(this, nguiMapComp, 'Polyline', INPUTS$13, OUTPUTS$13) || this;\n  }\n\n  return Polyline;\n}(BaseMapDirective);\n\nPolyline.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map > polyline',\n    inputs: INPUTS$13,\n    outputs: OUTPUTS$13\n  }]\n}];\n/**\n * @nocollapse\n */\n\nPolyline.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }];\n};\n\nvar INPUTS$14 = ['selector', 'options', 'addressControl', 'addressControlOptions', 'clickToGo', 'disableDefaultUI', 'disableDoubleClickZoom', 'enableCloseButton', 'fullscreenControl', 'fullscreenControlOptions', 'imageDateControl', 'linksControl', 'motionTracking', 'motionTrackingControl', 'panControl', 'panControlOptions', 'pano', 'position', 'pov', 'scrollwheel', 'showRoadLabels', 'visible', 'zoomControl', 'zoomControlOptions'];\nvar OUTPUTS$14 = ['closeclick', 'pano_changed', 'position_changed', 'pov_changed', 'resize', 'status_changed', 'visible_changed', 'zoom_changed'];\n\nvar StreetViewPanorama =\n/** @class */\nfunction (_super) {\n  __extends(StreetViewPanorama, _super);\n  /**\n   * @param {?} nguiMapComp\n   */\n\n\n  function StreetViewPanorama(nguiMapComp) {\n    return _super.call(this, nguiMapComp, 'StreetViewPanorama', INPUTS$14, OUTPUTS$14) || this;\n  }\n  /**\n   * @return {?}\n   */\n\n\n  StreetViewPanorama.prototype.initialize = function () {\n    this.objectOptions = this.optionBuilder.googlizeAllInputs(this.inputs, this);\n    var\n    /** @type {?} */\n    element;\n\n    if (this.objectOptions.selector) {\n      // noinspection TypeScriptValidateTypes\n      element = document.querySelector(this['selector']);\n      delete this.objectOptions.selector;\n    } else {\n      element = this.nguiMapComponent.el;\n    } // will be set after geocoded\n\n\n    typeof this.objectOptions.position === 'string' && delete this.objectOptions.position;\n    this.mapObject = new google.maps[this.mapObjectName](element, this.objectOptions);\n    this.mapObject['mapObjectName'] = this.mapObjectName;\n    this.mapObject['nguiMapComponent'] = this.nguiMapComponent; // set google events listeners and emits to this outputs listeners\n\n    this.nguiMap.setObjectEvents(this.outputs, this, 'mapObject');\n    this.nguiMapComponent.addToMapObjectGroup(this.mapObjectName, this.mapObject);\n    this.initialized$.emit(this.mapObject);\n  };\n  /**\n   * @return {?}\n   */\n\n\n  StreetViewPanorama.prototype.ngOnDestroy = function () {\n    if (this.nguiMapComponent.el) {\n      this.nguiMap.clearObjectEvents(this.outputs, this, 'mapObject');\n    }\n  };\n\n  return StreetViewPanorama;\n}(BaseMapDirective);\n\nStreetViewPanorama.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map > street-view-panorama',\n    inputs: INPUTS$14,\n    outputs: OUTPUTS$14\n  }]\n}];\n/**\n * @nocollapse\n */\n\nStreetViewPanorama.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }];\n};\n\nvar INPUTS$15 = ['autoRefresh', 'options'];\nvar OUTPUTS$15 = [];\n\nvar TrafficLayer =\n/** @class */\nfunction (_super) {\n  __extends(TrafficLayer, _super);\n  /**\n   * @param {?} nguiMapComp\n   */\n\n\n  function TrafficLayer(nguiMapComp) {\n    return _super.call(this, nguiMapComp, 'TrafficLayer', INPUTS$15, OUTPUTS$15) || this;\n  }\n\n  return TrafficLayer;\n}(BaseMapDirective);\n\nTrafficLayer.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map > traffic-layer',\n    inputs: INPUTS$15,\n    outputs: OUTPUTS$15\n  }]\n}];\n/**\n * @nocollapse\n */\n\nTrafficLayer.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }];\n};\n\nvar INPUTS$16 = [];\nvar OUTPUTS$16 = [];\n\nvar TransitLayer =\n/** @class */\nfunction (_super) {\n  __extends(TransitLayer, _super);\n  /**\n   * @param {?} nguiMapComp\n   */\n\n\n  function TransitLayer(nguiMapComp) {\n    return _super.call(this, nguiMapComp, 'TransitLayer', INPUTS$16, OUTPUTS$16) || this;\n  }\n\n  return TransitLayer;\n}(BaseMapDirective);\n\nTransitLayer.decorators = [{\n  type: Directive,\n  args: [{\n    selector: 'ngui-map > transit-layer',\n    inputs: INPUTS$16,\n    outputs: OUTPUTS$16\n  }]\n}];\n/**\n * @nocollapse\n */\n\nTransitLayer.ctorParameters = function () {\n  return [{\n    type: NguiMapComponent\n  }];\n};\n\nvar COMPONENTS_DIRECTIVES = [NguiMapComponent, InfoWindow, Marker, Circle, CustomMarker, Polygon, InfoWindow, Polyline, GroundOverlay, TransitLayer, TrafficLayer, HeatmapLayer, BicyclingLayer, KmlLayer, DataLayer, StreetViewPanorama, PlacesAutoComplete, DirectionsRenderer, DrawingManager];\n\nvar NguiMapModule =\n/** @class */\nfunction () {\n  function NguiMapModule() {}\n  /**\n   * @param {?=} config\n   * @return {?}\n   */\n\n\n  NguiMapModule.forRoot = function (config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    return {\n      ngModule: NguiMapModule,\n      providers: [{\n        provide: NG_MAP_CONFIG_TOKEN,\n        useValue: config\n      }]\n    };\n  };\n\n  return NguiMapModule;\n}();\n\nNguiMapModule.decorators = [{\n  type: NgModule,\n  args: [{\n    imports: [CommonModule],\n    declarations: COMPONENTS_DIRECTIVES,\n    exports: [COMPONENTS_DIRECTIVES],\n    providers: [GeoCoder, NavigatorGeolocation, NguiMap, OptionBuilder, {\n      provide: NgMapApiLoader,\n      useClass: NgMapAsyncCallbackApiLoader\n    }]\n  }]\n}];\n/**\n * @nocollapse\n */\n\nNguiMapModule.ctorParameters = function () {\n  return [];\n};\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { BicyclingLayer, NavigatorGeolocation, OptionBuilder, NG_MAP_CONFIG_TOKEN, NgMapApiLoader, NgMapAsyncApiLoader, NgMapAsyncCallbackApiLoader, NguiMapComponent, InfoWindow, CustomMarker, Circle, DataLayer, DirectionsRenderer, DrawingManager, GeoCoder, GroundOverlay, HeatmapLayer, KmlLayer, Marker, NguiMap, PlacesAutoComplete, Polygon, Polyline, StreetViewPanorama, TrafficLayer, TransitLayer, NguiMapModule, BaseMapDirective as a }; //# sourceMappingURL=map.es5.js.map","map":null,"metadata":{},"sourceType":"module"}